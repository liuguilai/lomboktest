Project Lombok makes java a spicier language by adding 'handlers' that know how to build and compile simple, boilerplate-free, not-quite-java code.
See LICENSE for the Project Lombok license.


To start, run:

ant -projecthelp

HINT: If you'd like to develop lombok in eclipse, run 'ant eclipse' first. It creates the necessary project infrastructure and downloads dependencies. Note that, in order to run "LombokizedEclipse.launch", you need to have "Eclipse SDK" installed.

HINT: This is the execution path of lombok: (ECJ which is Eclipse compiler is NOT fully discussed here (yet)).

- The file `javax.annotation.processing.Processor` in `META-INF/services` contains the value
    `lombok.launch.AnnotationProcessorHider$AnnotationProcessor`.

- `lombok.launch.AnnotationProcessorHider$AnnotationProcessor` is picked up by java annotation
    processor, instantiated, and its init() and process() are called.

- In `AnnotationProcessorHider`, `lombok.core.AnnotationProcessor` is instantiated from ClassLoader
    by reflection. init() and process() calls are delegated to it.

- `AnnotationProcessor` depending on current compiler, instantiates a `ProcessDescriptor` and
    delegates process() and init() calls to it. instead of init(), a `ProcessDescriptor` has a
    want() method who may bail out of later processing the env.

- `ProcessDescriptor` is the private *abstract* inner class of 'AnnotationProcessor'. Private inner
    implementations are `EcjDescriptor` and `JavacDescriptor` for the appropriate compilers.

- From now on, the `JavacDescriptor` for Oracle compiler is covered (NOT the ECJ).

- In case of `JavacDescriptor`, you can see class loader is patched upon the call to want(). to
    know why, read the link. Patching is for adding files at runtime to classpath. This is the
    general purpose but I don't know the specific reason for lombok?!
    http://stackoverflow.com/questions/1010919/adding-files-to-java-classpath-at-runtime.

- After patching class loader, appropriate processor is instantiated and the call to init() (which
    happen to become want()) and process() are delegated to it. In case of `JavacDescriptor`, The
    instantiated processor is `lombok.javac.apt.Processor`. Instantiation is done through the
    patched class loader.

The ceremony is over! now we discuss the actual init() and process() of Processor, who happens
to be `lombok.javac.apt.Processor`. `init()` is:

- placePostCompileAndDontMakeForceRoundDummiesHook() is called @TODO why?
- JavacTransformer is instantiated who will find annotation processors on class path for us.
    Loading and sorting is done through `HandlerLibrary` (an SPI utility).
- this.trees = Trees.instance(procEnv); @TODO what is this?

`Process()` is 4 steps. CU is CompilationUnit.

1. Take all CUs which aren't already in the map. Give them the first priority level.
    - who are the CUs NOT in the map? they are source files *generated by lombok* in previous
        round. @TODO is this correct? are we talking about un-processed and not-fully-processed CUs too?

2. For all CUs (in the map, not the roundEnv!), run them across all handlers at their current prio level.
    - Passing the CU to each handler is done by calling `transform` on the `transformer` object
        instantiated during init().

3. Push up all CUs to the next level. Set level to null if there is no next level.
    - So higher priority CUs are processed in correct order (in level 1).

4. If ALL values are null, quit. Else, either do another loop right now or force a resolution reset
    by forcing a new round in the annotation processor.


For a list of all authors, see the AUTHORS file. 

Project Lombok was started by: 

Reinier Zwitserloot
twitter: @surial
home: http://zwitserloot.com/

Roel Spilker
